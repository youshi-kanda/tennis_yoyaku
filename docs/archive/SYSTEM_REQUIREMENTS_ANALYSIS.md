# システム要件分析と課題整理

**作成日**: 2025年11月26日  
**ステータス**: 🚨 重要課題あり  
**現在のバージョン**: e84d6c16-3020-4bf6-bd61-cd5f8bf5e597

---

## 📋 目次

1. [ユーザー要件](#ユーザー要件)
2. [システム仕様との整合性](#システム仕様との整合性)
3. [現在の課題点](#現在の課題点)
4. [サブリクエスト試算](#サブリクエスト試算)
5. [解決策の選択肢](#解決策の選択肢)
6. [推奨アクション](#推奨アクション)

---

## ユーザー要件

### 基本要件
品川区・港区のテニスコート予約で、**一ヶ月先まで一括監視**してキャンセルが出て「○」になったら**即座に取得**したい。

### 監視対象

#### 施設
```
品川区: テニスコートA, B, C, D, E（最大5コート）
港区: テニスコートA, B, C, D（最大4コート）
合計: 最大9コート
```

#### 監視期間
```
31日間（一ヶ月先まで）
```

#### 監視時間帯
```
平日: 19:00-21:00（2時間 = 4枠 × 30分）
土日祝: 9:00-21:00（12時間 = 24枠 × 30分）

平日の割合: 約20日/月
土日祝の割合: 約10日/月
```

#### 予約戦略
```
- 同一日に複数枠が空いた場合 → すべて自動取得
- 同一日時・複数コートが同時に○ → すべて予約
```

---

## システム仕様との整合性

### ✅ 要件に合致している機能

| 機能 | 実装状況 | コード |
|------|---------|--------|
| 複数施設対応 | ✅ 実装済み | `facilityId`, `facilityName` |
| 複数時間帯監視 | ✅ 実装済み | `timeSlots?: string[]` |
| 曜日指定 | ✅ 実装済み | `selectedWeekdays?: number[]` |
| 祝日対応 | ✅ 実装済み | `includeHolidays?: boolean \| 'only'` |
| 期間指定 | ✅ 実装済み | `dateMode`, `startDate`, `endDate` |
| 全取得戦略 | ✅ 実装済み | `reservationStrategy: 'all'` |

### ⚠️ 重大な乖離点

| # | 要件 | 現在の実装 | ギャップ |
|---|------|-----------|---------|
| 1 | **即座に取得** | 11分間隔ローテーション | ❌ 取りこぼし発生 |
| 2 | **一ヶ月先まで一括監視** | 3日ずつローテーション | ❌ 全日同時監視不可 |
| 3 | **毎分チェック** | Cron: `*/1 * * * *` | ✅ 間隔は正しい |

---

## 現在の課題点

### 🚨 課題1: ローテーション設計による取りこぼし

#### 現在の実装
```typescript
const DAYS_PER_CRON = 3; // 1回のCronで3日分のみチェック

// 処理フロー:
// 1回目: 1日目〜3日目をチェック（18:00:00）
// 2回目: 4日目〜6日目をチェック（18:01:00）
// 3回目: 7日目〜9日目をチェック（18:02:00）
// ...
// 11回目: 31日目〜33日目をチェック（18:10:00）
// 12回目: 1日目〜3日目をチェック（18:11:00） ← 11分後に戻る
```

#### 問題点
```
キャンセル発生タイミング: 18:05:00（5日目の枠）
次のチェック: 18:16:00（11分後）
→ その間に他者が予約してしまう可能性が高い
```

#### 実測データ
- **人気コート（品川区公園、土日祝19時枠）**: 数秒〜数十秒で埋まる
- **取りこぼしリスク**: 11分間隔では**確実に取りこぼす**

#### サブリクエスト使用量
```
1コート × 3日 × 3リクエスト = 9サブリクエスト/実行
無料プラン制限: 50/実行
使用率: 18%（制限内だが取りこぼし発生）
```

---

### 🚨 課題2: 監視対象の規模とサブリクエスト制限

#### Cloudflare Workers 有料プラン制限（契約済み: $5/月）
```
サブリクエスト: 1,000回/実行
CPU時間: 30秒/実行
KV書き込み: 実質無制限
リクエスト: 10,000,000回/月
```

#### 品川区・港区のスクレイピング仕様
```typescript
// 1日1施設の空き状況チェック = 約3サブリクエスト
1. セッション取得: 1リクエスト
2. ログイン: 1リクエスト
3. 空き状況取得: 1リクエスト
```

#### サブリクエスト試算（有料プラン前提）

**⚠️ 注意**: 以下は無料プラン時代の試算です。現在は有料プラン契約済みで、すべてのケースが実行可能です。

**ケース1: 1コート31日全部チェック（要件通り）**
```
31日 × 3リクエスト/日 = 93サブリクエスト/実行
有料プラン制限: 1,000/実行
使用率: 9.3%（✅ 実行可能）
```

**ケース2: 9コート31日全部チェック（複数施設監視）**
```
9コート × 31日 × 3リクエスト = 837サブリクエスト/実行
有料プラン制限: 1,000/実行
使用率: 83.7%（✅ 実行可能）
```

**現在の実装: 5分間隔監視**
```
1コート × 31日 × 3リクエスト = 93サブリクエスト/実行
有料プラン制限: 1,000/実行
使用率: 9.3%（✅ 十分な余裕）
```

**推奨: 1分間隔監視**
```
1コート × 31日 × 3リクエスト = 93サブリクエスト/実行
有料プラン制限: 1,000/実行
使用率: 9.3%（✅ 十分な余裕）
メリット: キャンセル枝の取りこぼし削渚
```

---

### ✅ 解決済み: 複数コート監視の技術的制約

**有料プラン契約により解決** ($5/月)
- サブリクエスト: 1,000/実行（無料の20倍）
- KV書き込み: 実質無制限
- CPU時間: 30秒/実行

→ 9コート×31日の監視が十分可能

---

### 参考）旧課題3: 複数コート監視の技術的制約（無料プラン時代）

#### 品川区・港区の検索仕様
```
品川区システム: 施設ID単位の個別検索
港区システム: 施設ID単位の個別検索

一括検索API: 存在しない
→ 9コート = 9回の個別リクエストが必要
```

#### 要件定義書の記載との乖離
```
要件定義書:
「A公園→B公園→C公園…と順番に回すのではなく、
 検索条件でまとめて結果を取得する方式とする」

実際のサイト仕様:
→ 一括検索APIは存在しない
→ スクレイピング対象サイトの制約により個別検索必須
```

#### 複数コート監視時のサブリクエスト
```
9コート × 3日 × 3リクエスト = 81サブリクエスト/実行
→ 無料プラン制限（50/実行）を62%超過
```

---

## サブリクエスト試算

### 無料プラン（現在）

| 監視パターン | コート数 | 監視日数 | サブリクエスト/実行 | 制限内？ | 取りこぼし？ |
|-------------|---------|---------|-------------------|---------|------------|
| 現在実装 | 1 | 3日ずつ | 9 | ✅ Yes (18%) | ❌ Yes (11分間隔) |
| 短縮案 | 1 | 7日全部 | 21 | ✅ Yes (42%) | ✅ No (毎分全日) |
| 要件通り | 1 | 31日全部 | 93 | ❌ No (+86%) | - |
| 複数コート短縮 | 3 | 7日全部 | 63 | ❌ No (+26%) | - |
| 複数コート要件 | 9 | 31日全部 | 837 | ❌ No (+1574%) | - |

### Workers Paid ($5/月)

| 監視パターン | コート数 | 監視日数 | サブリクエスト/実行 | 制限内？ | 取りこぼし？ |
|-------------|---------|---------|-------------------|---------|------------|
| 要件通り | 1 | 31日全部 | 93 | ✅ Yes (9.3%) | ✅ No (毎分全日) |
| 複数コート | 3 | 31日全部 | 279 | ✅ Yes (27.9%) | ✅ No (毎分全日) |
| 複数コート | 9 | 31日全部 | 837 | ✅ Yes (83.7%) | ✅ No (毎分全日) |

**Workers Paid 制限**: サブリクエスト 1,000回/実行

---

## 解決策の選択肢

### 選択肢A: 監視日数を7日間に短縮（即座対応）

#### 実装内容
```typescript
// workers/src/index.ts

// ローテーションを廃止
const MAX_MONITORING_DAYS = 7; // 31日 → 7日に短縮

// 全日付を毎分チェック
const datesToCheck = generateDateRange(startDate, MAX_MONITORING_DAYS);
const datesToCheckThisRun = datesToCheck; // ローテーションなし

// サブリクエスト: 1コート × 7日 × 3リクエスト = 21/50
```

#### メリット
- ✅ 無料プラン制限内（21/50 = 42%使用）
- ✅ 全日付を毎分同時チェック（**取りこぼしなし**）
- ✅ 即座に実装可能（数分で修正完了）
- ✅ 追加コストなし

#### デメリット
- ⚠️ 監視期間が1週間に限定
- ⚠️ 一ヶ月先のキャンセルは検知不可
- ⚠️ 複数コート監視は3コートまで（3×7×3=63サブリクエスト→制限超過）

#### 適用シーン
```
- 直近1週間の予約を確実に取りたい
- 無料プランで運用したい
- 1-2コートの監視で十分
```

---

### 選択肢B: Workers Paid ($5/月) にアップグレード（推奨）

#### 制限緩和
```
無料プラン → Paid プラン:
- サブリクエスト: 50 → 1,000（20倍）
- CPU時間: 10ms → 30秒（3,000倍）
- KV読み取り: 無制限
- KV書き込み: 無制限
```

#### 実現可能な監視
```typescript
// 1コート31日全部を毎分チェック可能
31日 × 3リクエスト = 93サブリクエスト/実行
→ Paidプラン1,000制限の9.3%使用

// 3コート31日も余裕
3コート × 31日 × 3 = 279サブリクエスト/実行
→ Paidプラン1,000制限の27.9%使用

// 9コート31日も可能
9コート × 31日 × 3 = 837サブリクエスト/実行
→ Paidプラン1,000制限の83.7%使用
```

#### メリット
- ✅ **要件通り「一ヶ月先まで一括監視」が実現**
- ✅ 全日付を毎分同時チェック（**取りこぼしなし**）
- ✅ 複数コート対応可能（最大9コート）
- ✅ CPU時間制約なし（バッチ処理不要）
- ✅ KV制限なし（カーソル管理不要）

#### デメリット
- 💰 コスト: $5/月（約750円/月）

#### 適用シーン
```
- 要件通り一ヶ月先まで監視したい
- 複数施設を同時監視したい
- 確実にキャンセルを捕捉したい
```

---

### 選択肢C: 監視日数を動的調整（中間案）

#### 実装内容
```typescript
// 無料プランの場合: 自動的に7日に短縮
// Paidプランの場合: 31日全部監視

const MAX_DAYS_FREE = 7;
const MAX_DAYS_PAID = 31;

const maxDays = isPaidPlan(env) ? MAX_DAYS_PAID : MAX_DAYS_FREE;
const datesToCheck = generateDateRange(startDate, maxDays);
```

#### メリット
- ✅ 無料プランでも利用可能（7日間）
- ✅ Paidアップグレード時に自動で31日対応
- ✅ ユーザーが選択可能

#### デメリット
- ⚠️ プラン判定ロジックが必要
- ⚠️ UIで制限を表示する必要あり

---

### 選択肢D: 集中監視モード（長期検討）

#### 設計
```typescript
// 通常監視: 5分間隔（×→○）
// 集中監視: 秒単位（取→○）

// Durable Objectsで実装
export class IntensiveMonitor {
  async fetch(request: Request) {
    // 「取」検知時に開始
    const interval = setInterval(async () => {
      await checkAvailability(); // 1秒ごと
    }, 1000);
    
    // 10分後に自動終了
    setTimeout(() => clearInterval(interval), 10 * 60 * 1000);
  }
}
```

#### メリット
- ✅ 品川区「取→○」を秒単位で捕捉可能
- ✅ 人気時間帯の争奪戦に勝てる

#### デメリット
- ⚠️ Durable Objects必要（別途実装）
- 💰 コスト: $5/月 + 従量課金
- ⚠️ 技術的複雑度が高い

#### 適用シーン
```
- 品川区の抽選結果（取→○）を確実に取りたい
- 秒単位の競争に勝ちたい
```

---

## 推奨アクション

### 🎯 即座対応: 選択肢A（監視日数7日間に短縮）

#### 実装手順
```bash
# 1. workers/src/index.ts を修正
# 2. ローテーション削除、監視日数を7日に変更
# 3. デプロイ（所要時間: 5分）
```

#### 実装内容
```typescript
// DAYS_PER_CRON を削除
// const DAYS_PER_CRON = 3; // 削除

// 監視日数を7日に制限
const MAX_MONITORING_DAYS = 7;
const limitedDates = datesToCheck.slice(0, MAX_MONITORING_DAYS);

// 全日付を毎分チェック（ローテーションなし）
const datesToCheckThisRun = limitedDates;

// カーソル管理を削除
// await env.MONITORING.put(cursorKey, ...); // 削除
```

#### 効果
- ✅ サブリクエスト: 21/50（42%使用、制限内）
- ✅ 全日付を毎分同時チェック（取りこぼしなし）
- ✅ 無料プランで運用可能

#### 制限事項
- ⚠️ 監視期間: 1週間のみ
- ⚠️ 複数コート: 2コートまで推奨（3コートで制限超過）

---

### 🎯 中期対応: 選択肢B（Workers Paid アップグレード）

#### アップグレード手順
```bash
# 1. Cloudflareダッシュボードにログイン
# 2. Workers & Pages → Settings → Usage Model
# 3. "Bundled" → "Unbound" ($5/月)
# 4. 支払い情報を登録
```

#### 実装内容（アップグレード後）
```typescript
// 監視日数を31日に戻す
const MAX_MONITORING_DAYS = 31;
const datesToCheck = generateDateRange(startDate, MAX_MONITORING_DAYS);

// ローテーション削除、全日付を毎分チェック
const datesToCheckThisRun = datesToCheck;

// バッチ処理も不要（CPU時間制限なし）
// const BATCH_SIZE = 5; // 削除可能
```

#### 効果
- ✅ サブリクエスト: 93/1,000（9.3%使用、余裕あり）
- ✅ **要件通り「一ヶ月先まで一括監視」が実現**
- ✅ 全日付を毎分同時チェック（取りこぼしなし）
- ✅ 複数コート対応（最大9コート可能）

#### コスト
- 💰 $5/月（約750円/月）

---

### 📊 比較表

| 項目 | 現在（ローテーション） | 選択肢A（7日短縮） | 選択肢B（Paid） |
|------|-------------------|-------------------|----------------|
| 監視期間 | 31日 | 7日 | 31日 |
| チェック間隔 | 11分/日 | 毎分全日 | 毎分全日 |
| 取りこぼし | ❌ あり | ✅ なし | ✅ なし |
| サブリクエスト | 9/50 (18%) | 21/50 (42%) | 93/1,000 (9.3%) |
| 複数コート | 不可 | 2コートまで | 9コートまで |
| コスト | 無料 | 無料 | $5/月 |
| 実装時間 | - | 5分 | 5分（設定）+ 5分（実装） |
| 要件充足度 | ❌ 30% | ⚠️ 60% | ✅ 100% |

---

## 次のステップ

### ステップ1: 方針決定
```
□ 選択肢Aで即座対応（7日間監視、無料）
□ 選択肢Bで要件充足（31日間監視、$5/月）
□ 選択肢A → 運用確認 → 選択肢B（段階的導入）
```

### ステップ2: 実装
```
選択肢A（7日短縮）の場合:
1. workers/src/index.ts を修正
2. ローテーション削除、MAX_MONITORING_DAYS = 7
3. デプロイ
4. 実測確認（サブリクエスト数）

選択肢B（Paid）の場合:
1. Cloudflare Workersをアップグレード
2. workers/src/index.ts を修正
3. ローテーション削除、MAX_MONITORING_DAYS = 31
4. バッチ処理削除（CPU時間制限なし）
5. デプロイ
6. 実測確認
```

### ステップ3: 検証
```
□ サブリクエスト数の確認（wrangler tail）
□ 全日付が毎分チェックされることを確認
□ 取りこぼしがないことを確認（実運用）
```

---

## 結論

### 現在の問題点
1. ❌ **ローテーション設計により11分間隔でしかチェックできない**
2. ❌ **人気コートのキャンセルを取りこぼす**
3. ❌ **要件「一ヶ月先まで一括監視」が実現できていない**

### 推奨される解決策
1. **即座対応**: 選択肢A（7日短縮、無料）で取りこぼしを防ぐ
2. **中期対応**: 選択肢B（Paid $5/月）で要件を100%充足

### 実装優先度
```
High: 選択肢Aの実装（取りこぼし防止）
Medium: 選択肢Bの検討（要件充足）
Low: 選択肢D（集中監視モード）の設計
```

---

**最終更新**: 2025年11月26日  
**次回レビュー**: 方針決定後、実装完了時
