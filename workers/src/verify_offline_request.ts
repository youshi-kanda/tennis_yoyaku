
// Mock Verification Script
// This script simulates the Shinagawa site responses and verifies the HTTP Request Body
// generated by makeShinagawaReservation to confirm redundant parameters are present.

import { makeShinagawaReservation } from './scraper/shinagawa';
import { ShinagawaSession } from './scraper/types';

declare const process: {
    env: { [key: string]: string | undefined };
    exit: (code?: number) => never;
};

// Mock Helper: Create a fake Response
const createResponse = (bodyText: string, status = 200, headers: Record<string, string> = {}) => {
    return {
        ok: status >= 200 && status < 300,
        status,
        headers: new Map(Object.entries(headers)),
        text: async () => bodyText,
        arrayBuffer: async () => new TextEncoder().encode(bodyText),
    } as unknown as Response;
};

async function main() {
    console.log('--- Offline Verification: Request Structure Check ---');

    // 1. Mock Session
    const mockSession: ShinagawaSession = {
        cookie: 'JSESSIONID=mock_session_id',
        loginJKey: 'mock_login_jkey',
        displayNo: 'prwrc2000',
        errorParams: {},
        userAgent: 'MockAgent/1.0'
    };

    console.log('1. Prepared Mock Session');

    // 2. Mock Fetch Implementation
    // We want to capture the request to 'rsvWOpeReservedApplyAction.do' (Details Entry)
    // But first, makeShinagawaReservation calls:
    //  - rsvWOpeInstSrchVacantAction.do (Ajax Selection)
    //  - rsvWInstUseruleRsvApplyAction.do (Terms)
    //  - rsvWInstRsvApplyAction.do (Final Apply) -- Wait, DryRun might stop before this?

    // We are interested in the Step 1 (Ajax Selection) request body to confirm `selectBldCd` etc.
    // AND the Step 2/3 requests.

    let capturedBodies: Record<string, string> = {};

    const mockFetch = async (url: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
        const urlStr = url.toString();

        // Capture Request Body
        if (init && init.body) {
            const bodyStr = init.body.toString();
            console.log(`\n[MockFetch] Request to: ${urlStr}`);
            // console.log(`[MockFetch] Body: ${bodyStr.substring(0, 150)}...`); 

            if (urlStr.includes('rsvWOpeInstSrchVacantAction.do')) {
                capturedBodies['step1_ajax'] = bodyStr;
            } else if (urlStr.includes('rsvWOpeReservedApplyAction.do')) {
                capturedBodies['step2_transition'] = bodyStr;
            } else if (urlStr.includes('rsvWInstUseruleRsvApplyAction.do')) {
                capturedBodies['step3_terms'] = bodyStr;
            } else if (urlStr.includes('rsvWInstRsvApplyAction.do')) {
                capturedBodies['step4_details'] = bodyStr;
            }
        }

        // Return Mock Responses to keep the flow moving
        if (urlStr.includes('rsvWOpeInstSrchVacantAction.do')) {
            // Return Step 1 Response (Selection Snippet) with some hidden fields
            const mockHiddenHtml = `
                <input type="hidden" name="selectBldName" value="MockBuilding">
                <input type="hidden" name="selectInstName" value="MockStation">
                <input type="hidden" name="insIRsvJKey" value="MOCK_SESSION_KEY_12345">
            `;
            // Should be SJIS encoded but our code handles it. TextEncoder uses UTF-8 which decoder might fail on if strictly SJIS?
            // createResponse uses TextEncoder(utf-8). scraper uses TextDecoder('windows-31j') which falls back or handles ascii fine.
            return createResponse(mockHiddenHtml);
        }

        if (urlStr.includes('rsvWOpeReservedApplyAction.do')) {
            // Step 2 Response (Terms Page)
            const mockTermsHtml = `
                <html><body>
                <form name="form1" action="rsvWInstUseruleRsvApplyAction.do">
                <input type="checkbox" name="ruleFg" value="1">
                </form>
                </body></html>
            `;
            return createResponse(mockTermsHtml);
        }

        if (urlStr.includes('rsvWInstUseruleRsvApplyAction.do')) {
            // Step 3 Response (Details Page)
            // Needs to contain the form for next step if logic parses it? 
            // Actually makeShinagawaReservation logic just fetches this and then constructs params for next step manually or based on inputs?
            // It searches for insIRsvJKey in the response?

            const mockDetailsHtml = `
                <html><body>
                <input type="hidden" name="insIRsvJKey" value="MOCK_SESSION_KEY_VERIFIED">
                <select name="purpose" id="purpose0"><option value="31000000_31011700" selected>Tennis</option></select>
                </body></html>
            `;
            return createResponse(mockDetailsHtml);
        }

        return createResponse('<html>Mock Default</html>');
    };

    // 3. Execute Logic
    console.log('2. Running makeShinagawaReservation (Dry Run) against Mock...');

    try {
        await makeShinagawaReservation(
            '10100010', // Facility ID
            '2026-01-25',
            '09:00-11:00',
            mockSession,
            { applicantCount: 2, eventName: 'TestEvent' },
            undefined,
            true, // DryRun
            mockFetch // Inject Mock
        );
    } catch (e) {
        // Expected to fail or finish? DryRun should finish success.
        console.log('Execution finished (may have thrown if parsing failed strictly, but we care about request bodies)');
    }

    // 4. Verification Analysis
    console.log('\n--- Analysis of Captured Requests ---');

    // Check Step 1 (Ajax) for Redundant Parameters
    const step1Body = capturedBodies['step1_ajax'];
    if (step1Body) {
        console.log('Checking Step 1 (Ajax) Params:');
        const params = new URLSearchParams(step1Body);

        const checks = [
            { key: 'bldCd', expected: true },
            { key: 'selectBldCd', expected: true }, // Redundant
            { key: 'instCd', expected: true },
            { key: 'selectInstCd', expected: true }, // Redundant
            { key: 'ppsCd', expected: true },
            { key: 'selectPpsCd', expected: true }, // Redundant
            { key: 'ppsClsCd', expected: true },
            { key: 'selectPpsClsCd', expected: true }, // Redundant
        ];

        let pass = true;
        checks.forEach(check => {
            const val = params.get(check.key);
            const exists = val !== null && val !== '';
            if (exists === check.expected) {
                console.log(`  ✅ ${check.key}: ${val}`);
            } else {
                console.log(`  ❌ ${check.key}: Missing or Empty`);
                pass = false;
            }
        });

        if (pass) {
            console.log('\n[SUCCESS] Step 1 Request contains all redundant parameters.');
        } else {
            console.log('\n[FAILED] Step 1 Request is missing some Redundant parameters.');
        }

    } else {
        console.error('[FAILED] Step 1 Ajax Request was never sent!');
    }

}

main().catch(console.error);
